# JSON Data Type: Enterprise Data Management in Oracle Database 23ai

## Introduction

Welcome to the **JSON Data Type** lab! This hands-on session explores Oracle Database 23ai's revolutionary native JSON data type and its powerful capabilities for storing, querying, and managing complex business data across any industry.

Building on the domains and annotations concepts from the previous lab, this session demonstrates how to combine structured data validation with flexible document storage, creating modern enterprise applications that balance data integrity with adaptability. While our examples use LumenCare's healthcare scenario, the principles and benefits apply to any industry requiring flexible data management.

Estimated Lab Time: 35 minutes

**Key JSON Enhancements in Oracle Database 23ai**

**JSON Schema Validation**
Enforce document structure using JSON Schema while maintaining flexibility for optional fields and dynamic content.

**Enhanced JSON Constructor**
Create JSON documents directly from SQL queries, collections, and PL/SQL objects with simplified syntax.

**Advanced SQL/JSON Functions**
- **JSON_ARRAY with Subqueries**: Generate arrays from query results
- **JSON_TRANSFORM**: Modify documents with conditional logic and calculations
- **JSON_SERIALIZE with ORDERED**: Consistent field ordering for predictable output

**Multi-Value Indexes**
Specialized indexes that efficiently query JSON arrays and nested structures, dramatically improving performance for complex document queries.

### Objective:
The objective of this lab is to demonstrate Oracle Database 23ai's native JSON data type capabilities for enterprise applications. By the end of this lab, you will understand how to create tables with JSON columns, query JSON data efficiently, and leverage advanced JSON features for flexible business data management.

### Prerequisites:
- Access to Oracle Database 23ai.
- Basic understanding of SQL concepts.
- Completion of Domains & Annotations lab.

## Task 1: Creating Enterprise Tables with JSON Integration

1. Let's create tables that combine the domains from our previous lab with Oracle's native JSON data type for flexible business data management. While we're using LumenCare's healthcare scenario for our demonstration, these patterns apply to any industry that needs structured data validation combined with flexible document storage.

    **Note**: This lab assumes you have completed the **Domains & Annotations** lab and the required domains (`healthcare_id`, `person_name`, `medical_status`, `gender_type`) already exist in your database.

2. Let's create a patients table that uses our domains from the previous lab to demonstrate structured data validation.

    ```sql
    <copy>
    CREATE TABLE IF NOT EXISTS patients (
      id                healthcare_id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      name              person_name NOT NULL,
      dob               DATE,
      sex               gender_type,
      primary_reason    VARCHAR2(200),
      created_at        TIMESTAMP DEFAULT SYSTIMESTAMP,
      last_updated      TIMESTAMP DEFAULT SYSTIMESTAMP,
      full_name_upper   VARCHAR2(100) GENERATED ALWAYS AS (
        UPPER(name)
      ) VIRTUAL
    ) 
    ANNOTATIONS (
      hipaa_compliant 'Core patient demographics',
      data_classification 'Highly sensitive PII',
      business_purpose 'Patient identity and demographic tracking',
      table_comment 'Patient master data with HIPAA compliance'
    );
    </copy>
    ```

3. Now we'll create an appointments table that combines domain validation with Oracle's native JSON data type for flexible metadata storage.

    This is where Oracle Database 23ai's JSON capabilities shine:

    ```sql
    <copy>
    CREATE TABLE IF NOT EXISTS appointments (
      id                healthcare_id GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      patient_id        healthcare_id NOT NULL,
      start_time        TIMESTAMP NOT NULL,
      end_time          TIMESTAMP GENERATED ALWAYS AS (
        start_time + INTERVAL '30' MINUTE
      ) VIRTUAL,
      reason            VARCHAR2(200),
      status            medical_status DEFAULT 'Scheduled',
      created_at        TIMESTAMP DEFAULT SYSTIMESTAMP,
      provider_name     person_name DEFAULT 'Dr. Rivera',
      -- Native JSON column showcasing Oracle 23ai capabilities
      appointment_data  JSON,
      CONSTRAINT appointments_patient_fk FOREIGN KEY (patient_id) 
        REFERENCES patients(id) ON DELETE CASCADE
    )
    ANNOTATIONS (
      business_purpose 'Healthcare appointment scheduling and tracking',
      data_retention '5 years post appointment',
      audit_required 'Yes - track all status changes',
      json_features 'Utilizes Oracle 23ai native JSON type with OSON storage'
    );
    </copy>
    ```

    **Key JSON Features Demonstrated:**
    - **Native JSON Type**: `appointment_data JSON` uses optimized OSON binary storage
    - **Schema Flexibility**: No predefined structure required for JSON documents  
    - **Performance**: Faster than CLOB or VARCHAR2 JSON storage
    - **Integration**: Seamless interaction with relational columns and constraints

## Task 2: Testing Domain Constraints During Data Insertion

Before adding valid data, let's demonstrate how domain constraints protect data integrity during insertion attempts.

1. Before adding valid data, let's test how domain constraints protect data integrity by attempting to insert invalid data.

    ```sql
    <copy>
    -- This will fail - invalid healthcare_id (negative number)
    INSERT INTO patients (id, name, dob, sex) 
    VALUES (-1, 'Invalid Patient', DATE '1990-01-01', 'Male');
    </copy>
    ```

    ```sql
    <copy>
    -- This will fail - person_name too short (less than 2 characters)
    INSERT INTO patients (name, dob, sex) 
    VALUES ('A', DATE '1990-01-01', 'Male');
    </copy>
    ```

    ```sql
    <copy>
    -- This will fail - invalid medical_status (not in enumeration)
    INSERT INTO appointments (patient_id, start_time, reason, status)
    VALUES (1, TIMESTAMP '2025-02-16 14:00:00', 'Check-up', 'Invalid Status');
    </copy>
    ```

    ```sql
    <copy>
    -- This will fail - invalid gender_type (not in enumeration)  
    INSERT INTO patients (name, dob, sex) 
    VALUES ('Test Patient', DATE '1990-01-01', 'InvalidGender');
    </copy>
    ```

    Each failure demonstrates how domains enforce data integrity at the database level, preventing invalid data from entering the system.

## Task 3: Inserting Rich Healthcare Data with JSON

Now let's populate our tables with realistic healthcare data that showcases both domain validation and JSON flexibility.

1. Let's start by inserting our three base patients that will be used throughout the lab examples.

    ```sql
    <copy>
    -- BASE PATIENTS (as provided)
    INSERT INTO patients (name, dob, sex, primary_reason) 
    VALUES ('Courtney Henry', DATE '1988-06-10', 'Female', 'Knee rehab follow-up');

    INSERT INTO patients (name, dob, sex, primary_reason) 
    VALUES ('Ronald Richards', DATE '1982-02-01', 'Male', 'Back-to-running check-in');

    INSERT INTO patients (name, dob, sex, primary_reason) 
    VALUES ('Leslie Alexander', DATE '1976-11-03', 'Female', 'Blood pressure review');

    COMMIT;
    </copy>
    ```

2. Now we'll add appointments for each patient, showcasing how JSON can store varied metadata structures for different appointment types.

    #### Courtney Henry - Knee Rehabilitation Journey

    ```sql
    <copy>
    -- APPOINTMENTS FOR COURTNEY HENRY (Patient ID 1 - Knee Rehab)

-- Initial knee rehab follow-up appointment
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (1, TIMESTAMP '2025-08-12 09:30:00', 'Knee rehab progress evaluation', 'Completed', 'Dr. Jennifer Park',
        JSON('{"appointmentType": "orthopedic", "duration": 45, "specialty": "sports medicine", "followUpWeeks": 6, "painLevel": 3, "mobilityImprovement": true}'));

-- Physical therapy session
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (1, TIMESTAMP '2025-08-15 14:00:00', 'Physical therapy session', 'Completed', 'Mike Thompson, PT',
        JSON('{"appointmentType": "physicalTherapy", "duration": 60, "exercisesFocused": ["quad strengthening", "range of motion"], "homeExerciseUpdate": true}'));

-- Follow-up orthopedic visit
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (1, TIMESTAMP '2025-08-22 10:15:00', 'Knee function assessment', 'Scheduled', 'Dr. Jennifer Park',
        JSON('{"appointmentType": "orthopedic", "duration": 30, "imagingNeeded": false, "returnToActivityDiscussion": true}'));

-- Upcoming PT session
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (1, TIMESTAMP '2025-08-26 15:30:00', 'Advanced strengthening exercises', 'Scheduled', 'Mike Thompson, PT',
        JSON('{"appointmentType": "physicalTherapy", "duration": 60, "phase": "strengthening", "sportSpecificTraining": true}'));
    </copy>
    ```

    #### Ronald Richards - Running Assessment Program

    ```sql
    <copy>
    -- APPOINTMENTS FOR RONALD RICHARDS (Patient ID 2 - Running Assessment)

-- Running gait analysis
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (2, TIMESTAMP '2025-08-09 08:00:00', 'Running gait analysis and biomechanics', 'Completed', 'Dr. Sarah Kim',
        JSON('{"appointmentType": "sportsMedicine", "duration": 60, "gaitAnalysis": true, "videoAnalysis": true, "currentMileage": 25, "goalMileage": 40}'));

-- Podiatry consultation
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (2, TIMESTAMP '2025-08-14 11:45:00', 'Foot mechanics and shoe fitting', 'Completed', 'Dr. Michael Torres, DPM',
        JSON('{"appointmentType": "podiatry", "duration": 45, "footScan": true, "shoeRecommendation": "motion control", "customOrthotics": false}'));

-- Sports medicine follow-up
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (2, TIMESTAMP '2025-08-21 16:30:00', 'Training plan optimization', 'Scheduled', 'Dr. Sarah Kim',
        JSON('{"appointmentType": "sportsMedicine", "duration": 30, "trainingPlanReview": true, "injuryPrevention": true, "racePreparation": "10K"}'));

-- Nutrition consultation
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (2, TIMESTAMP '2025-08-28 13:00:00', 'Sports nutrition and hydration', 'Scheduled', 'Lisa Chen, RD',
        JSON('{"appointmentType": "nutrition", "duration": 45, "focus": "endurance nutrition", "supplementDiscussion": true, "hydratorStrategy": true}'));
    </copy>
    ```

    #### Leslie Alexander - Blood Pressure Management

    ```sql
    <copy>
    -- APPOINTMENTS FOR LESLIE ALEXANDER (Patient ID 3 - Blood Pressure)

-- Blood pressure monitoring visit
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (3, TIMESTAMP '2025-08-07 10:00:00', 'Blood pressure monitoring and medication review', 'Completed', 'Dr. Rivera',
        JSON('{"appointmentType": "primaryCare", "duration": 30, "bpReading": "138/86", "medicationAdjustment": true, "homeMonitoringReview": true}'));

-- Cardiology consultation
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (3, TIMESTAMP '2025-08-16 14:30:00', 'Hypertension management consultation', 'Completed', 'Dr. Robert Chen, MD',
        JSON('{"appointmentType": "cardiology", "duration": 45, "echocardiogram": true, "arteryAssessment": true, "lifestyleModifications": true}'));

-- Dietitian appointment
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (3, TIMESTAMP '2025-08-20 09:30:00', 'DASH diet counseling', 'Scheduled', 'Maria Rodriguez, RD',
        JSON('{"appointmentType": "nutrition", "duration": 60, "dietType": "DASH", "sodiumReduction": true, "mealPlanning": true, "weightManagement": false}'));

-- Follow-up BP check
INSERT INTO appointments (patient_id, start_time, reason, status, provider_name, appointment_data)
VALUES (3, TIMESTAMP '2025-08-30 08:45:00', 'Blood pressure recheck', 'Scheduled', 'Dr. Rivera',
        JSON('{"appointmentType": "primaryCare", "duration": 15, "bpRecheck": true, "medicationEffectiveness": true, "homeLogReview": true}'));

COMMIT;
    </copy>
    ```

    **JSON Flexibility Demonstrated:**
    - **Varied Structures**: Each business event type can store different metadata fields without predefined schemas
    - **Mixed Data Types**: Strings, numbers, booleans, and arrays coexist naturally within documents
    - **Native Storage**: OSON format ensures optimal performance and storage efficiency across all document types
    - **Schema Evolution**: New business requirements can add fields without altering table structure or application downtime

## Task 4: Powerful JSON Querying for Enterprise Analytics

Oracle Database 23ai provides sophisticated JSON querying capabilities that make complex business document data as accessible and performant as traditional relational data.

1. Let's explore how to access JSON properties using Oracle's simple dot notation syntax.

    ```sql
    <copy>
    -- Access JSON properties using dot notation
    SELECT 
        p.name as patient_name,
        a.reason,
        a.status,
        a.appointment_data.appointmentType as appointment_type,
        a.appointment_data.duration as duration_minutes
    FROM appointments a
    JOIN patients p ON a.patient_id = p.id
    ORDER BY a.start_time;
    </copy>
    ```

2. Now we'll filter our data based on JSON content to find specific types of appointments.

    ```sql
    <copy>
    -- Find all orthopedic appointments
    SELECT 
        p.name as patient_name,
        a.reason,
        a.appointment_data.appointmentType as specialty,
        a.appointment_data.painLevel as pain_level
    FROM appointments a
    JOIN patients p ON a.patient_id = p.id
    WHERE a.appointment_data.appointmentType = 'orthopedic'
    ORDER BY a.start_time;
    </copy>
    ```

3. Let's see how Oracle handles JSON arrays, particularly for appointments that include exercise lists.

    ```sql
    <copy>
    -- Find appointments with specific exercise focuses (JSON arrays)
    SELECT 
        p.name as patient_name,
        a.reason,
        JSON_QUERY(a.appointment_data, '$.exercisesFocused[*]' RETURNING VARCHAR2(4000) PRETTY) as exercises
    FROM appointments a
    JOIN patients p ON a.patient_id = p.id
    WHERE JSON_EXISTS(a.appointment_data, '$.exercisesFocused');
    </copy>
    ```

4. We'll perform aggregation queries on JSON data to analyze appointment patterns and generate business insights.

    ```sql
    <copy>
    -- Analyze appointment patterns by type
    SELECT 
        JSON_VALUE(a.appointment_data, '$.appointmentType') as appointment_type,
        COUNT(*) as appointment_count,
        AVG(JSON_VALUE(a.appointment_data, '$.duration' RETURNING NUMBER)) as avg_duration_minutes,
        MIN(JSON_VALUE(a.appointment_data, '$.duration' RETURNING NUMBER)) as min_duration,
        MAX(JSON_VALUE(a.appointment_data, '$.duration' RETURNING NUMBER)) as max_duration
    FROM appointments a
    WHERE JSON_VALUE(a.appointment_data, '$.appointmentType') IS NOT NULL
    GROUP BY JSON_VALUE(a.appointment_data, '$.appointmentType')
    ORDER BY appointment_count DESC;
    </copy>
    ```

## Task 5: Advanced JSON Operations

1. Let's use JSON_TRANSFORM to modify existing JSON documents and add calculated fields.

    ```sql
    <copy>
    -- Transform JSON data to add calculated fields
    SELECT 
        p.name,
        a.reason,
        JSON_TRANSFORM(
            a.appointment_data,
            SET '$.calculatedEndTime' = 
                TO_CHAR(a.start_time + 
                    INTERVAL '1' MINUTE * 
                    JSON_VALUE(a.appointment_data, '$.duration' RETURNING NUMBER), 
                    'YYYY-MM-DD"T"HH24:MI:SS'),
            SET '$.patientName' = p.name
        ) as enhanced_appointment_data
    FROM appointments a
    JOIN patients p ON a.patient_id = p.id
    WHERE a.id <= 3;
    </copy>
    ```

2. We'll create more sophisticated queries that search for specific conditions within JSON documents.

    ```sql
    <copy>
    -- Find appointments with specific conditions using JSON_EXISTS
    SELECT 
        p.name,
        a.reason,
        a.appointment_data.appointmentType as type,
        JSON_VALUE(a.appointment_data, '$.bpReading') as blood_pressure
    FROM appointments a
    JOIN patients p ON a.patient_id = p.id
    WHERE JSON_EXISTS(a.appointment_data, '$.bpReading')
       OR JSON_EXISTS(a.appointment_data, '$.painLevel');
    </copy>
    ```

3. Let's generate JSON summaries from our relational data, combining both structured and document approaches.

    ```sql
    <copy>
    -- Generate JSON summaries from relational data
    SELECT 
        p.name,
        JSON_OBJECT(
            'patientInfo' VALUE JSON_OBJECT(
                'name' VALUE p.name,
                'dob' VALUE p.dob,
                'sex' VALUE p.sex,
                'primaryReason' VALUE p.primary_reason
            ),
            'appointmentCount' VALUE COUNT(*),
            'appointmentTypes' VALUE JSON_ARRAYAGG(
                JSON_VALUE(a.appointment_data, '$.appointmentType')
            ),
            'totalDuration' VALUE SUM(JSON_VALUE(a.appointment_data, '$.duration' RETURNING NUMBER))
        ) as patient_summary
    FROM patients p
    LEFT JOIN appointments a ON p.id = a.patient_id
    GROUP BY p.id, p.name, p.dob, p.sex, p.primary_reason;
    </copy>
    ```

## Task 6: Performance Optimization with JSON Indexes

Oracle Database 23ai provides specialized indexing for JSON data to ensure optimal query performance.

1. We'll create indexes on frequently queried JSON properties to improve query performance.

    ```sql
    <copy>
    -- Index for fast appointment type queries
    CREATE INDEX idx_appointment_type ON appointments (
        JSON_VALUE(appointment_data, '$.appointmentType')
    );

    -- Index for duration-based queries
    CREATE INDEX idx_appointment_duration ON appointments (
        JSON_VALUE(appointment_data, '$.duration' RETURNING NUMBER)
    );
    </copy>
    ```

-- 2. Let's create Oracle 23ai's specialized multi-value indexes to efficiently query JSON arrays.

--     ```sql
--     <copy>
-- INSERT INTO appointments (
--   patient_id, start_time, reason, status, provider_name, appointment_data
-- )
-- VALUES (
--   1,
--   TIMESTAMP '2025-08-15 14:00:00',
--   'Physical therapy session',
--   'Completed',
--   'Mike Thompson, PT',
--   JSON('{"appointmentType":"physicalTherapy","duration":60,"exercisesFocused":["quad strengthening","range of motion"],"homeExerciseUpdate":true}')
-- );

--     -- Multi-value index for JSON arrays (Oracle 23ai feature)
--   CREATE MULTIVALUE INDEX idx_exercises ON
--    appointments (
--       JSON_VALUE(appointment_data,
--   '$.exercisesFocused[*]' RETURNING
--   VARCHAR2(100))
--   );
--     </copy>
--     ```

3. Now we'll test how these indexes improve performance for complex JSON array queries.

    ```sql
    <copy>
    -- Query that benefits from the multi-value index
    SELECT 
        p.name,
        a.reason,
        JSON_QUERY(a.appointment_data, '$.exercisesFocused[*]' RETURNING VARCHAR2(4000) PRETTY) as exercises
    FROM appointments a
    JOIN patients p ON a.patient_id = p.id
    WHERE JSON_VALUE(a.appointment_data, '$.exercisesFocused[*]' RETURNING VARCHAR2(100)) = 'quad strengthening';
    </copy>
    ```

## Task 7: JSON Schema-like Validation

While Oracle 23ai supports full JSON Schema validation, we can also implement basic validation using check constraints.

1. Let's add check constraints to ensure our JSON documents contain required fields and valid data.

    ```sql
    <copy>
    -- Ensure appointment_data always has appointmentType
    ALTER TABLE appointments ADD CONSTRAINT appointment_data_required
    CHECK (JSON_EXISTS(appointment_data, '$.appointmentType') = 1);

    -- Ensure duration is a positive number when present
    ALTER TABLE appointments ADD CONSTRAINT appointment_duration_valid
    CHECK (
        JSON_VALUE(appointment_data, '$.duration' RETURNING NUMBER) IS NULL OR
        JSON_VALUE(appointment_data, '$.duration' RETURNING NUMBER) > 0
    );
    </copy>
    ```

2. We'll test our JSON validation constraints by attempting to insert invalid JSON data.

    ```sql
    <copy>
    -- This should fail - missing appointmentType
    INSERT INTO appointments (patient_id, start_time, reason, status, appointment_data)
    VALUES (1, TIMESTAMP '2025-09-01 10:00:00', 'Test appointment', 'Scheduled',
            JSON('{"duration": 30, "notes": "Missing appointment type"}'));
    </copy>
    ```

## Task 8: JSON Data Guide and Schema Discovery

Oracle provides tools to understand the structure of your JSON documents.

1. Let's use Oracle's JSON Data Guide feature to analyze the structure of our JSON documents.

    ```sql
    <copy>
    -- Analyze the structure of JSON documents
    SELECT JSON_DATAGUIDE(appointment_data, DBMS_JSON.PRETTY) as data_guide
    FROM appointments
    WHERE ROWNUM = 1;
    </copy>
    ```

2. We'll query statistics about our JSON document structures to understand data patterns.

    ```sql
    <copy>
    -- Get statistics about JSON document structures
    SELECT 
        JSON_VALUE(appointment_data, '$.appointmentType') as appointment_type,
        COUNT(*) as document_count,
        COUNT(JSON_VALUE(appointment_data, '$.duration')) as has_duration,
        COUNT(JSON_VALUE(appointment_data, '$.painLevel')) as has_pain_level,
        COUNT(JSON_QUERY(appointment_data, '$.exercisesFocused')) as has_exercises
    FROM appointments
    GROUP BY JSON_VALUE(appointment_data, '$.appointmentType')
    ORDER BY document_count DESC;
    </copy>
    ```

## Conclusion

In this lab, you've experienced Oracle Database 23ai's revolutionary JSON capabilities combined with structured domain validation:

1. **Native JSON Type**: OSON binary storage delivers superior performance and space efficiency
2. **Advanced Querying**: SQL/JSON functions provide powerful document manipulation capabilities
3. **Flexible Indexing**: Multi-value indexes optimize complex JSON array queries
4. **Schema Evolution**: Documents adapt to changing requirements without database schema changes
5. **Perfect Integration**: JSON works seamlessly with domains, constraints, and traditional SQL

This combination positions Oracle Database 23ai as the ideal platform for modern applications that need both the reliability of structured data and the flexibility of document storage.

## Learn More

* [Oracle Database 23ai JSON Developer's Guide](https://docs.oracle.com/en/database/oracle/oracle-database/23/adjsn/index.html)
* [JSON Data Type in Oracle Database](https://docs.oracle.com/en/database/oracle/oracle-database/23/adjsn/json-data-type.html)
* [Multi-Value Indexes for JSON](https://docs.oracle.com/en/database/oracle/oracle-database/23/adjsn/indexes-for-json-data.html)
* [JSON Schema Validation](https://docs.oracle.com/en/database/oracle/oracle-database/23/adjsn/json-schema.html)

## Acknowledgements
* **Author** - Killian Lynch, Database Product Management
* **Last Updated By/Date** - Killian Lynch, August 2025
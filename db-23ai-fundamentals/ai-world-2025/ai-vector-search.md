# Lab: Oracle AI Vector Search for Healthcare Documents

## Introduction

Welcome to the **Oracle AI Vector Search** lab! In this hands-on session, you'll explore Oracle Database 23ai's powerful AI Vector Search capabilities using the LumenCare healthcare scenario.

Building on the patient data from our previous labs, you'll learn how to create vector embeddings from healthcare documents stored in Oracle Cloud Infrastructure (OCI) Object Storage and perform semantic searches to find relevant medical information. This technology enables healthcare professionals to quickly find similar cases, treatment protocols, and medical research based on meaning rather than exact keyword matches.

Estimated Lab Time: 25 minutes

### What You'll Learn

- How to load text documents from OCI Object Storage using Pre-Authenticated Request (PAR) URLs
- Creating vector tables with Oracle 23ai's AI Vector Search
- Generating embeddings for semantic similarity searches
- Performing vector searches on healthcare documents
- Connecting vector search results to existing patient data

### Prerequisites

- Access to Oracle Database 23ai
- Completion of previous LumenCare labs (recommended)
- Basic SQL knowledge


## Task 1: Load the Embedding Model for Vector Search

in order to create embeddings and perform vector searches, you'll need an embedding model. Oracle Database allows you to optionally load embedding models into the database to perform secure embedding. In this task, you'll load the **ALL_MiniLM_L12_v2** model that has been staged in Oracle Cloud Infrastructure Object Storage. This model will be used to create our vectors.

### Understanding the Embedding Process

Vector search enables semantic similarity matching by converting text into high-dimensional numerical vectors called embeddings. Similar content produces similar vectors, allowing the database to find related information based on meaning rather than exact text matches.

The ALL_MiniLM_L12_v2 model is a lightweight transformer model optimized for generating high-quality sentence embeddings that work perfectly with Oracle's native vector search capabilities.

1. **Create and execute the embedding model loader script**. The following PL/SQL block will:

    - Download the pre-trained ONNX model from Oracle's Object Storage
    - Load it into your database as `ALL_MINILM_L12_V2`
    - Make it available for generating embeddings in subsequent tasks

    **Expected Result:** You should see output confirming the model was successfully loaded with the name `ALL_MINILM_L12_V2`. This model will be used throughout the remaining tasks to generate vector embeddings for our healthcare documents.

    **Note:** This one-time setup process enables Oracle Database to generate embeddings locally without requiring external API calls, providing better performance and data security for healthcare applications. 

    ```sql
    <copy>
    DECLARE 
        ONNX_MOD_FILE VARCHAR2(100) := 'all_MiniLM_L12_v2.onnx';
        MODNAME VARCHAR2(500);
        LOCATION_URI VARCHAR2(200) := 'https://adwc4pm.objectstorage.us-ashburn-1.oci.customer-oci.com/p/eLddQappgBJ7jNi6Guz9m9LOtYe2u8LWY19GfgU8flFK4N9YgP4kTlrE9Px3pE12/n/adwc4pm/b/OML-Resources/o/';

    BEGIN
        DBMS_OUTPUT.PUT_LINE('ONNX model file name in Object Storage is: '||ONNX_MOD_FILE); 

        SELECT UPPER(REGEXP_SUBSTR(ONNX_MOD_FILE, '[^.]+')) INTO MODNAME from dual;
        DBMS_OUTPUT.PUT_LINE('Model will be loaded and saved with name: '||MODNAME);

        BEGIN DBMS_DATA_MINING.DROP_MODEL(model_name => MODNAME); EXCEPTION WHEN OTHERS THEN NULL; END;

        DBMS_CLOUD.GET_OBJECT(                            
            credential_name => NULL,
            directory_name => 'DATA_PUMP_DIR',
            object_uri => LOCATION_URI || ONNX_MOD_FILE);

        DBMS_VECTOR.LOAD_ONNX_MODEL(
            directory => 'DATA_PUMP_DIR',
            file_name => ONNX_MOD_FILE,
            model_name => MODNAME);

        DBMS_OUTPUT.PUT_LINE('New model successfully loaded with name: '||MODNAME);
    END;
    </copy>
    ```

2. Now Check ONNX Runtime availability
    ```sql
    <copy>
    SELECT model_name, mining_function
    FROM user_mining_models
    WHERE model_name = 'ALL_MINILM_L12_V2';
    </copy>
    ```

## Task 2: Set Up Vector Search Infrastructure

Before we can perform vector searches, we need to configure the necessary database components. Oracle 23ai provides built-in AI vector capabilities that integrate seamlessly with existing data.

```sql
<copy>

-- First, let's create our vector search schema objects
CREATE TABLE IF NOT EXISTS healthcare_documents (
    doc_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
    title VARCHAR2(200),
    content CLOB,
    document_type VARCHAR2(50),
    created_date DATE DEFAULT SYSDATE,
    CONSTRAINT pk_healthcare_docs PRIMARY KEY (doc_id)
);

-- Add vector column for embeddings
ALTER TABLE healthcare_documents ADD (
    content_vector VECTOR(384, FLOAT32)
);

</copy>
```

**Expected Result:** You'll have created a table with vector capabilities and an index optimized for similarity searches.

---

## Task 3: Load Healthcare Documents from Object Storage
  -- Task 3: Load Healthcare Documents from Object Storage using DBMS_CLOUD with PAR URLs

  -- Load healthcare documents directly from Object Storage using PAR URLs
  -- Uses actual titles from the text files
```sql
DECLARE
  l_blob       BLOB;
  l_content    CLOB;
  l_title      VARCHAR2(500);
  l_first_line VARCHAR2(1000);
  l_doc_count  PLS_INTEGER := 0;

  TYPE url_array IS VARRAY(100) OF VARCHAR2(2000);
  l_file_urls url_array := url_array(
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/RABrqCcgMgQu5S1Oaef1rw9CyJDsQcBSV-zR-0JF4-ngMa40B5-k98jcY7Nm324U/n/oradbclouducm/b/aiworld-demo/o/archived_messages_courtney.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/GfyR3g0jaxIGCFXQlt6fulmVNykepZyKr5YKGzckVlTiU4Ir5EgJVEvWTjlMClkA/n/oradbclouducm/b/aiworld-demo/o/archived_messages_leslie.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/vfSH4mtNtZfPkV5-j01w2_U6ds1omrJzVxbTdyVrgzlOtqX0PFILWqiYTtYGaiXW/n/oradbclouducm/b/aiworld-demo/o/archived_messages_ronald.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/cN6ENqsyUM9pY_jnzSQe-tbkxC_u5fY_W-fLvt78WQK0WMumOLcFr77y_nJ9TWmr/n/oradbclouducm/b/aiworld-demo/o/discharge_summary_courtney.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/5Jvp2kEGYAEkp_adwXPRiciYB_EFdDqRuVvbkuIsztHfpewhKMxfHvg_oVtUI3f6/n/oradbclouducm/b/aiworld-demo/o/insurance_authorization.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/bY27qJ1P8lXunYkdVHRPc0AaXunWIz7rrnkMiLzayiHit930J_3o8B91Pqw89OoF/n/oradbclouducm/b/aiworld-demo/o/lab_results_leslie.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/QERHSl1De3T83sdSuRSEEJTR0tNNTmqQlVDVZXF7Y-8RZLCPNLxiy-l21DTQmyro/n/oradbclouducm/b/aiworld-demo/o/nutrition_consultation_leslie.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/CdGUFAi-_-w3yKm6P-qLZhdMCHWyeQ-0SLe48iunW8Fcos1vjjirJqDFSjAfhuml/n/oradbclouducm/b/aiworld-demo/o/patient_notes_courtney.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/-cWeLF1HHeDMOuHBA_723ci7Evat47qo61nsMx1AB5DXxoV397NeyLgevNQR061Q/n/oradbclouducm/b/aiworld-demo/o/physical_therapy_notes.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/pw__8bxYVzWiHdBDjkrOFzMf__iOcr5VJOKp4Cq-Wgcbs8BjkBl2xSKIsbo9EZpW/n/oradbclouducm/b/aiworld-demo/o/radiology_report_ronald.txt',
        'https://objectstorage.us-ashburn-1.oraclecloud.com/p/AaB4w3cX_Fubi_0NCDzIsM0JU2kbBIL79K5EQo_ubkiBVJ_4OzAWH1JWjC2qY2Ta/n/oradbclouducm/b/aiworld-demo/o/specialist_referral_ronald.txt'
    );
    -- add more URLs here
BEGIN
  DBMS_OUTPUT.PUT_LINE('Loading healthcare documents from Object Storage...');

  FOR i IN 1 .. l_file_urls.COUNT LOOP
    -- 1) fetch bytes into memory (function form)
    l_blob := DBMS_CLOUD.GET_OBJECT(
               credential_name => NULL,          -- ok for a pre-authenticated URL
               object_uri      => l_file_urls(i)
             );

    -- 2) convert to text (explicit UTF-8 decode; safer than CAST_TO_VARCHAR2)
    l_content := UTL_I18N.RAW_TO_CHAR(l_blob, 'AL32UTF8');

    -- 3) derive a title from the first line
    l_first_line := REGEXP_SUBSTR(l_content, '^[^' || CHR(10) || CHR(13) || ']*');
    l_title := TRIM(l_first_line);

    -- 4) insert WITHOUT embedding for now
    INSERT INTO healthcare_documents (title, content, document_type, content_vector)
    VALUES (l_title, l_content, 'Healthcare Document', NULL);

    l_doc_count := l_doc_count + 1;
    DBMS_OUTPUT.PUT_LINE('✓ Loaded: ' || l_title);
  END LOOP;

  COMMIT;
  DBMS_OUTPUT.PUT_LINE('Successfully loaded ' || l_doc_count || ' documents.');
END;
/
  </copy>
```

```sql
<copy>
  -- Verify the loaded documents
  SELECT doc_id,
         title,
         document_type,
         LENGTH(content) as content_length,
         SUBSTR(content, 1, 150) || '...' as content_preview
  FROM healthcare_documents
  ORDER BY doc_id;

  </copy>
```


---

## Task 4: Generate Vector Embeddings

1. Oracle 23ai can generate embeddings using built-in AI capabilities. We'll create vector representations of our healthcare documents that capture their semantic meaning.

    ```
    <copy>
        UPDATE healthcare_documents
        SET content_vector = VECTOR_EMBEDDING(ALL_MINILM_L12_V2 USING content AS DATA)
        WHERE content IS NOT NULL;
        COMMIT;
    </copy>
    ```
    What’s going on here?
    Think of a vector as a point in space. In two dimensions, that might be an (x, y) coordinate on a graph. But embeddings are 384 dimensions — far too big to draw — so we use math to measure closeness.
    * When we say “similarity,” we really mean distance.
    * If two documents are “close” in vector space, they’re semantically similar.
    * Oracle gives us the function VECTOR_DISTANCE to calculate that closeness.

    Smaller distance = more similar.
2. Look at one of the vectors 

    ```
    <copy>
        SELECT doc_id,
            title,
            content_vector
    FROM healthcare_documents
    FETCH FIRST 1 ROW ONLY;
    </copy>
    ```

## Task 5: Perform Basic Vector Similarity Searches

1. Now let's perform semantic searches to find similar healthcare documents. Vector search finds content with similar meaning, even if the exact words differ.

    Let’s try something practical. We’ll embed a short English phrase, turn it into a query vector, then order our documents by cosine distance to that query.

2. Suppose a clinician wants to quickly find all records related to blood pressure management.
    ```
    <copy>
    -- Search for documents similar to a diabetes query
    WITH search_query AS (
        SELECT VECTOR_EMBEDDING(
            AI_EMBED USING ALL_MINILM_L12_V2 
            DATA 'diabetes management and blood sugar control'
        ) as query_vector
        FROM dual
    )
    SELECT hd.doc_id, 
        hd.title,
        hd.document_type,
        ROUND(VECTOR_DISTANCE(hd.content_vector, sq.query_vector, COSINE), 4) as similarity_score,
        SUBSTR(hd.content, 1, 100) || '...' as content_preview
    FROM healthcare_documents hd, search_query sq
    ORDER BY VECTOR_DISTANCE(hd.content_vector, sq.query_vector, COSINE) ASC
    FETCH FIRST 3 ROWS ONLY;
    </copy>
    ```
    What you’ll see near the top:
    * Leslie’s secure messages discussing Lisinopril and DASH diet
    * The nutrition consultation notes about reducing sodium
    * Her lipid panel with cholesterol results

    One short phrase pulls together patient communications, labs, and diet counseling — no keywords needed.

3. Now let’s look for Courtney’s recovery notes.
    ```
    <copy>
    WITH q AS (
    SELECT VECTOR_EMBEDDING(ALL_MINILM_L12_V2 USING
            'meniscus repair discharge instructions and physical therapy progression' AS DATA) AS v
    FROM dual
    )
    SELECT d.doc_id,
        d.title,
        SUBSTR(d.content, 1, 180) || '...' AS snippet,
        VECTOR_DISTANCE(d.content_vector, q.v, COSINE) AS distance
    FROM healthcare_documents d
    CROSS JOIN q
    ORDER BY distance
    FETCH FIRST 5 ROWS ONLY;
    </copy>
    ```
    Expected results:
    * Courtney’s discharge summary after arthroscopic repair
    * Physical therapy session notes showing progress
    * Orthopedic follow-up clinic note
    * Even the MRI authorization appears, because it’s part of the same clinical episode

4. Let's try one more. 

    ```
    <copy>
    WITH q AS (
    SELECT VECTOR_EMBEDDING(ALL_MINILM_L12_V2 USING
            'overpronation running gait analysis foot x-ray findings' AS DATA) AS v
    FROM dual
    )
    SELECT d.doc_id,
        d.title,
        SUBSTR(d.content, 1, 180) || '...' AS snippet,
        VECTOR_DISTANCE(d.content_vector, q.v, COSINE) AS distance
    FROM healthcare_documents d
    CROSS JOIN q
    ORDER BY distance
    FETCH FIRST 5 ROWS ONLY;
    </copy>
    ```

    Likely matches:
    * Radiology foot X-ray showing flatfoot/overpronation
    * Sports medicine consult with cadence and form recommendations
    * Patient messages about training goals and soreness

    This gives a complete view of the gait assessment — imaging, specialist report, and the patient’s own words.

## Task 6: Combining Vector Search with Relational Data

1. So far, we’ve searched our healthcare documents by meaning alone. That’s powerful, but in real-world healthcare you almost always want to connect unstructured data (notes, lab reports, messages) with structured data (patient demographics, visit info, billing records).

    Oracle Database 23ai shines here because it’s a converged database. We can join vector results with relational tables in the same SQL query.

    Think about a provider who asks:

    “Show me which of my patients recently had knee surgery notes and physical therapy updates.”

    A pure vector search will surface the right documents. But by joining with the patients table, we can also return the patient name and other structured attributes right alongside.

    Let's update our demo a bit. Run the following SQL to enhance the workshop

    ```
    <copy>
    ALTER TABLE healthcare_documents ADD (patient_id NUMBER);

    ALTER TABLE healthcare_documents
    ADD CONSTRAINT fk_healthcare_docs_patient
    FOREIGN KEY (patient_id) REFERENCES patients(id);

    -- Courtney Henry (meniscus repair, PT, follow-ups, auth)
    UPDATE healthcare_documents d
    SET patient_id = (SELECT id FROM patients WHERE name = 'Courtney Henry')
    WHERE patient_id IS NULL
    AND (
            DBMS_LOB.INSTR(d.content, 'Patient: Courtney Henry') > 0
        OR DBMS_LOB.INSTR(d.content, 'Name: Courtney Henry')    > 0
    );

    -- Leslie Alexander (BP messages, lipid panel, DASH nutrition consult)
    UPDATE healthcare_documents d
    SET patient_id = (SELECT id FROM patients WHERE name = 'Leslie Alexander')
    WHERE patient_id IS NULL
    AND (
            DBMS_LOB.INSTR(d.content, 'Patient: Leslie Alexander') > 0
        OR DBMS_LOB.INSTR(d.content, 'Name: Leslie Alexander')    > 0
    );

    -- Ronald Richards (gait consult, foot X-ray, running thread)
    UPDATE healthcare_documents d
    SET patient_id = (SELECT id FROM patients WHERE name = 'Ronald Richards')
    WHERE patient_id IS NULL
    AND (
            DBMS_LOB.INSTR(d.content, 'Patient: Ronald Richards') > 0
        OR DBMS_LOB.INSTR(d.content, 'Name: Ronald Richards')    > 0
    );

    COMMIT;
    </copy>
    ```

2. Let’s embed a simple phrase — “meniscus repair discharge instructions and physical therapy progression” — and then return the top matching docs with the patient’s name included.

    ```
    <copy>
    WITH q AS (
    SELECT VECTOR_EMBEDDING(ALL_MINILM_L12_V2 USING
            'blood pressure readings and hypertension management' AS DATA) AS v
    FROM dual
    )
    SELECT p.name  AS patient_name,
        d.title AS document_title,
        SUBSTR(d.content, 1, 180) || '...' AS snippet,
        VECTOR_DISTANCE(d.content_vector, q.v, COSINE) AS distance
    FROM healthcare_documents d
    JOIN patients p ON p.id = d.patient_id
    CROSS JOIN q
    ORDER BY distance
    FETCH FIRST 5 ROWS ONLY;
    </copy>
    ``` 
    What to expect in your results:
    * Courtney Henry – Arthroscopic meniscus repair discharge summary
    * Courtney Henry – Physical therapy session notes
    * Courtney Henry – Orthopedic clinic follow-up
    * Sometimes also her MRI authorization

    Notice how the results not only show the right documents, but also clearly identify the patient they belong to.

3. Now let’s search for “blood pressure readings and hypertension management”:

    ```
    <copy>
    WITH q AS (
    SELECT VECTOR_EMBEDDING(ALL_MINILM_L12_V2 USING
            'blood pressure readings and hypertension management' AS DATA) AS v
    FROM dual
    )
    SELECT p.name  AS patient_name,
        d.title AS document_title,
        SUBSTR(d.content, 1, 180) || '...' AS snippet,
        VECTOR_DISTANCE(d.content_vector, q.v, COSINE) AS distance
    FROM healthcare_documents d
    JOIN patients p ON p.id = d.patient_id
    CROSS JOIN q
    ORDER BY distance
    FETCH FIRST 5 ROWS ONLY;
    </copy>
    ```
    Likely results:
    * Leslie Alexander – Secure message thread about BP + Lisinopril
    * Leslie Alexander – Lipid panel with borderline LDL
    * Leslie Alexander – Nutrition consult with DASH diet


## Task 7: Creating Vector Indexes

1. Now we'll learn about Oracle Database 23ai's vector indexing capabilities. Vector indexes are essential for scaling vector search operations as your document corpus grows, providing significant performance improvements for approximate nearest neighbor (ANN) searches.

  Oracle 23ai provides two main types of vector indexes optimized for different use cases:
    - **In-Memory Neighbor Graph Vector Index**: Uses Hierarchical Navigable Small World (HNSW) graphs for fast searches
    - **Neighbor Partition Vector Index**: Uses Inverted File Flat (IVF) approach for balanced performance

  In Autonomous Database, the vector memory size is automatically managed, making vector index creation and management much simpler than in traditional Oracle databases.

2. First, let's understand why vector indexes are important by running a query without an index and observing the execution plan.

    ```sql
    <copy>
    -- Check current execution plan for vector search without index
    EXPLAIN PLAN FOR
    WITH q AS (
        SELECT VECTOR_EMBEDDING(ALL_MINILM_L12_V2 USING
               'blood pressure readings and hypertension management' AS DATA) AS v
        FROM dual
    )
    SELECT doc_id, title,
           VECTOR_DISTANCE(content_vector, q.v, COSINE) AS distance
    FROM healthcare_documents d
    CROSS JOIN q
    ORDER BY distance
    FETCH FIRST 5 ROWS ONLY;

    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY());
    </copy>
    ```

    **What you'll observe:** Without a vector index, Oracle performs a full table scan, computing distance for every vector - inefficient as data grows.

3. Vector indexes provide several benefits:
    - **Speed**: Convert linear O(n) searches to approximately O(log n) 
    - **Scalability**: Essential when dealing with thousands or millions of vectors
    - **Accuracy Control**: Configurable precision vs performance trade-offs
    - **Memory Efficiency**: Optimized storage and retrieval patterns

4. **Create your first vector index** - In-Memory Neighbor Graph Vector Index 

    ```sql
    <copy>
    -- Create In-Memory Neighbor Graph Vector Index
    -- This type is optimized for fast, accurate searches
    CREATE VECTOR INDEX idx_healthcare_content_inmemory
    ON healthcare_documents(content_vector)
    ORGANIZATION INMEMORY NEIGHBOR GRAPH
    DISTANCE COSINE
    WITH TARGET ACCURACY 95;
    </copy>
    ```

    **What this does:**
    - `INMEMORY NEIGHBOR GRAPH`: Uses HNSW algorithm for fast searches
    - `DISTANCE COSINE`: Matches our search queries (always align with your search metric)
    - `TARGET ACCURACY 95`: Aims for 95% accuracy vs exact brute-force search

2. We can check the status of the vector index in the user indexes table just as expected
    ```sql
    <copy>
    -- Check index status
    SELECT index_name, index_type, status, 
           ityp_owner, ityp_name
    FROM user_indexes 
    WHERE index_name = 'IDX_HEALTHCARE_CONTENT_INMEMORY';
    </copy>
    ```

3. **Alternative: Create a Neighbor Partition Vector Index** (for comparison):

    ```sql
    <copy>
    -- First drop the previous index
    DROP INDEX idx_healthcare_content_inmemory;

    -- Create Neighbor Partition Vector Index
    -- This type balances speed with memory usage
    CREATE VECTOR INDEX idx_healthcare_content_partition  
    ON healthcare_documents(content_vector)
    ORGANIZATION NEIGHBOR PARTITIONS
    DISTANCE COSINE
    WITH TARGET ACCURACY 95;
    </copy>
    ```

    **Key differences:**
    - **NEIGHBOR PARTITIONS**: Uses IVF (Inverted File Flat) approach
    - Better for larger datasets with memory constraints
    - Slightly different performance characteristics


3. **Important index management best practices:**

    - **Keep distance metrics consistent**: Always use the same distance metric (COSINE, EUCLIDEAN, etc.) in both index creation and queries
    - **Monitor accuracy vs performance**: Higher TARGET_ACCURACY values provide better results but use more resources  
    - **Regular statistics**: Keep table statistics current for optimal query plans
    - **Autonomous advantages**: In Autonomous Database, vector memory is auto-managed, eliminating manual tuning


## Conclusion

Congratulations! You've successfully implemented Oracle AI Vector Search for healthcare documents using Oracle Database 23ai. 


## Learn More

* [Oracle Database 23ai AI Vector Search Documentation](https://docs.oracle.com/en/database/oracle/oracle-database/23/vecse/index.html)
* [Vector Data Type Guide](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/vector.html)
* [AI Vector Search Functions](https://docs.oracle.com/en/database/oracle/oracle-database/23/sqlrf/vector-functions.html)

## Acknowledgements
* **Author** - Killian Lynch, Database Product Management
* **Last Updated By/Date** - Killian Lynch, August 2025